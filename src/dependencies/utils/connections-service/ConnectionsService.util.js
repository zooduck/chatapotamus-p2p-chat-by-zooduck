/**
 * @typedef {import('./typedef.js')}
 */

import { sendCustomEventMixin } from '../../../modules/@zooduck/send-custom-event-mixin/dist/index.module.js';
import { DataChannelMessageType, sendDataChannelMessage } from '../sendDataChannelMessage.util.js';

/**
 * Service for creating and managing RTCPeerConnections.
 *
 * @mixes SendCustomEvent
 */
class ConnectionsService extends sendCustomEventMixin() {
  #connections;
  #iceCandidateGatheringPromises;
  #incomingFiles;
  #mediaStreamService;
  /**
   * @param {EventService} eventService
   * @param {MediaStreamService} mediaStreamService
   */
  constructor(mediaStreamService) {
    super();
    this.#connections = new Map();
    this.#incomingFiles = new Map();
    this.#mediaStreamService = mediaStreamService;
    this.#iceCandidateGatheringPromises = new Map();
  }
  /**
   * @type {Object.<string, string>}
   */
  static get ConnectionType() {
    return {
      LOCAL: 'local',
      REMOTE: 'remote'
    };
  }
  get ConnectionType() {
    return this.constructor.ConnectionType;
  }
  /**
   * @static
   * @readonly
   * @type {Object.<string, string>}
   */
  static get EventDict() {
    return {
      CONNECTION_CLOSE: this.#createEventTypeWithNamespace('connectionclose'),
      CONNECTION_INFO: this.#createEventTypeWithNamespace('connectioninfo'),
      DATA_CHANNEL_CLOSE: this.#createEventTypeWithNamespace('datachannelclose'),
      DATA_CHANNEL_MESSAGE: this.#createEventTypeWithNamespace('datachannelmessage'),
      DATA_CHANNEL_OPEN: this.#createEventTypeWithNamespace('datachannelopen'),
      REMOTE_CAMERA_TRACK_DISABLE: this.#createEventTypeWithNamespace('remotecameratrackdisable'),
      REMOTE_CAMERA_TRACK_ENABLE: this.#createEventTypeWithNamespace('remotecameratrackenable'),
      REMOTE_FILE_CHUNK_RECEIVED: this.#createEventTypeWithNamespace('remotefilechunkreceived'),
      REMOTE_FILE_RECEIVED: this.#createEventTypeWithNamespace('remotefilereceived'),
      REMOTE_FILE_TRANSFER_FAIL: this.#createEventTypeWithNamespace('remotefiletransferfail'),
      REMOTE_FILE_TRANSFER_START: this.#createEventTypeWithNamespace('remotefiletransferstart'),
      REMOTE_MICROPHONE_TRACK_ENABLE: this.#createEventTypeWithNamespace('remotemicrophonetrackenable'),
      REMOTE_USER_MEDIA_TRACKS_DISABLE: this.#createEventTypeWithNamespace('remoteusermediatracksdisable'),
      REMOTE_SCREEN_SHARE: this.#createEventTypeWithNamespace('remotescreenshare'),
      REMOTE_SCREEN_SHARE_END: this.#createEventTypeWithNamespace('remotescreenshareend'),
    }
  }
  get EventDict() {
    return this.constructor.EventDict;
  }
  /**
   * @private
   * @static
   * @method
   * @returns {string}
   */
  static #createEventTypeWithNamespace(eventType) {
    return this.name.toLowerCase() + eventType;
  }
  /**
   * @method
   * @param {string} connectionID
   * @param {string} remoteConnectionID
   * @param {RTCConfiguration} rtcConfig
   * @returns {Promise<RTCPeerConnection>}
   */
  addAnswererConnection(connectionID, remoteConnectionID, rtcConfig) {
    return new Promise((resolve) => {
      const remoteConnection = new RTCPeerConnection(rtcConfig);
      let iceCandidateGatheringStateCompleteResolve;
      this.#iceCandidateGatheringPromises.set(remoteConnection, new Promise((resolve) => {
        iceCandidateGatheringStateCompleteResolve = resolve;
      }));

      this.#connections.set(remoteConnectionID, {
        connection: remoteConnection,
        channel: null,
        incomingMediaStreams: new Map(),
        type: this.ConnectionType.REMOTE
      });

      let dataChannel;

      remoteConnection.onicecandidate = (event) => {
        this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
          detail: {
            log: ['ICE (Interactive Connectivity Establishment) Candidate Generated By %s.', connectionID]
          }
        });
        if (event.target.iceGatheringState === 'complete') {
          this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
            detail: {
              log: ['ICE (Interactive Connectivity Establishment) Candidate Gathering For %s Complete.', connectionID]
            }
          });

          iceCandidateGatheringStateCompleteResolve();
        }
      };

      remoteConnection.ondatachannel = (event) => {
        dataChannel = event.channel;

        this.#connections.get(remoteConnectionID).channel = dataChannel;

        dataChannel.onopen = () => {
          this.#mediaStreamService.publishCamera([remoteConnection]);
          this.#mediaStreamService.publishMicrophone([remoteConnection]);
          this.#mediaStreamService.publishScreen([remoteConnection]);

          this.sendCustomEvent(this.EventDict.DATA_CHANNEL_OPEN, {
            detail: {
              channelOwner: JSON.parse(dataChannel.label).createdBy,
              remoteConnectionID: remoteConnectionID
            }
          });

          this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
            detail: {
              log: ['Connection successfully established with %s!', remoteConnectionID]
            }
          });
        };

        // -------------------------------------------------------------------------------------------------------
        // When either this (remote) connection or the local connection is closed using RTCPeerConnection.close()
        // the "close" event will fire on the data channel subscribed to by this (remote) connection.
        // -------------------------------------------------------------------------------------------------------
        dataChannel.onclose = () => {
          this.sendCustomEvent(this.EventDict.DATA_CHANNEL_CLOSE, {
            detail: {
              remoteConnectionID: remoteConnectionID
            }
          });
        };

        dataChannel.onmessage = (event) => {
          this.#onDataChannelMessage.call(this, event, remoteConnection, connectionID, remoteConnectionID);
        }
      }

      remoteConnection.ontrack = (event) => {
        const [remoteMediaStream] = event.streams;
        this.#addIncomingMediaStreamToConnection(remoteConnectionID, remoteMediaStream);
      };

      remoteConnection.onnegotiationneeded = () => {
        // -------------------------------------------------------------------------------------
        // This event fires when a MediaStreamTrack is added to or removed from the connection.
        // -------------------------------------------------------------------------------------
        this.#createOffer(remoteConnection).then((sdpOffer) => {
          this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
            detail: {
              log: [
                'SDP (Session Description Protocol) Offer For %s Created By %s:%o',
                remoteConnectionID,
                connectionID,
                sdpOffer
              ]
            }
          });
          sendDataChannelMessage({
            type: DataChannelMessageType.SDP_OFFER,
            sdpOffer: sdpOffer
          }, dataChannel);
        });
      };
    });
  }

  /**
   * @method
   * @param {string} connectionID
   * @param {string} remoteConnectionID
   * @param {RTCConfiguration} rtcConfig
   * @returns {Promise<RTCSessionDescription>}
   */
  addOffererConnection(connectionID, remoteConnectionID, rtcConfig) {
    return new Promise((resolve) => {
      if (!rtcConfig?.iceServers) {
        throw new Error('Invalid RTC Configuration');
      }

      const localConnection = new RTCPeerConnection(rtcConfig);
      const dataChannelLabel = JSON.stringify({ createdBy: connectionID });
      const dataChannel = localConnection.createDataChannel(dataChannelLabel);

      let iceCandidateGatheringStateCompleteResolve;
      this.#iceCandidateGatheringPromises.set(localConnection, new Promise((resolve) => {
        iceCandidateGatheringStateCompleteResolve = resolve;
      }));

      this.#connections.set(remoteConnectionID, {
        connection: localConnection,
        channel: dataChannel,
        incomingMediaStreams: new Map(),
        type: this.ConnectionType.LOCAL
      });

      localConnection.onicecandidate = (event) => {
        this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
          detail: {
            log: ['ICE (Interactive Connectivity Establishment) Candidate Generated By %s.', connectionID]
          }
        });
        if (event.target.iceGatheringState === 'complete') {
          this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
            detail: {
              log: ['ICE (Interactive Connectivity Establishment) Candidate Gathering For %s Complete.', connectionID]
            }
          });

          iceCandidateGatheringStateCompleteResolve();
        }
      };

      dataChannel.onopen = () => {
        this.#mediaStreamService.publishCamera([localConnection]);
        this.#mediaStreamService.publishMicrophone([localConnection]);
        this.#mediaStreamService.publishScreen([localConnection]);

        this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
          detail: {
            log: ['Connection successfully established with %s!', remoteConnectionID]
          }
        });

        this.sendCustomEvent(this.EventDict.DATA_CHANNEL_OPEN, {
          detail: {
            channelOwner: JSON.parse(dataChannel.label).createdBy,
            remoteConnectionID: remoteConnectionID
          }
        });
      };

      // -------------------------------------------------------------------------------------------------------
      // When either this (local) connection or the remote connection is closed using RTCPeerConnection.close()
      // the "close" event will fire on the data channel created by this (local) connection.
      // -------------------------------------------------------------------------------------------------------
      dataChannel.onclose = () => {
        this.sendCustomEvent(this.EventDict.DATA_CHANNEL_CLOSE, {
          detail: {
            remoteConnectionID: remoteConnectionID
          }
        });
      };

      dataChannel.onmessage = (event) => {
        this.#onDataChannelMessage.call(this, event, localConnection, connectionID, remoteConnectionID);
      }

      localConnection.ontrack = (event) => {
        const [remoteMediaStream] = event.streams;
        this.#addIncomingMediaStreamToConnection(remoteConnectionID, remoteMediaStream);
      };

      localConnection.onnegotiationneeded = (event) => {
        // ----------------------------------------------------------------
        // This event fires when:
        // - createDataChannel() is called on the connection
        // - a MediaStreamTrack is added to or removed from the connection
        // ----------------------------------------------------------------
        this.#createOffer(localConnection).then((sdpOffer) => {
          if (dataChannel.readyState !== 'open') {
            const { localDescription } = localConnection;
            const localDescriptionWithOffererAndAnswererIncluded = this.#addOffererAndAnswererToSessionDescription(localDescription, connectionID, remoteConnectionID);

            this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
              detail: {
                log: [
                  'SDP (Session Description Protocol) Offer For %s Created By %s:%o',
                  remoteConnectionID,
                  connectionID,
                  localDescriptionWithOffererAndAnswererIncluded
                ]
              }
            });

            return resolve(localDescriptionWithOffererAndAnswererIncluded);
          }
          sendDataChannelMessage({
            type: DataChannelMessageType.SDP_OFFER,
            sdpOffer: sdpOffer
          }, dataChannel);
        });
      };
    });
  }

  /**
   * @method
   * @param {{
   *  connection: RTCPeerConnection,
   *  connectionID: string,
   *  remoteConnectionID: string,
   *  sessionDesciptionAnswer: RTCSessionDescription
   * }} options
   * @returns {Promise<void>}
   */
  async setAnswer(options) {
    const {
      connection,
      connectionID,
      remoteConnectionID,
      sessionDesciptionAnswer
    } = options;

    await this.#setAnswer(connection, sessionDesciptionAnswer);

    this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
      detail: {
        log: [
          'SDP (Session Description Protocol) Answer From %s Set On %s:%o',
          remoteConnectionID,
          connectionID,
          sessionDesciptionAnswer
        ]
      }
    });
  }

  /**
   * @method
   * @param {{
   *  connection: RTCPeerConnection,
   *  connectionID: string,
   *  remoteConnectionID: string,
   *  sessionDescriptionOffer: RTCSessionDescription,
   *  addConnectionIDsToSessionDescription?: boolean
   * }} options
   * @returns {Promise<RTCSessionDescription>} sessionDescriptionAnswer
   */
  async setOffer(options) {
    const {
      connection,
      connectionID,
      remoteConnectionID,
      sessionDescriptionOffer,
      addConnectionIDsToSessionDescription = false
    } = options;

    const sessionDescriptionAnswer = await this.#createAnswer(connection, sessionDescriptionOffer);
    let sessionDescriptionAnswerWithOffererAndAnswererIncluded;

    if (addConnectionIDsToSessionDescription) {
      sessionDescriptionAnswerWithOffererAndAnswererIncluded = this.#addOffererAndAnswererToSessionDescription(sessionDescriptionAnswer, remoteConnectionID, connectionID);
    }

    this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
      detail: {
        log: [
          'SDP (Session Description Protocol) Offer From %s Set On %s:%o',
          remoteConnectionID,
          connectionID,
          sessionDescriptionOffer
        ]
      }
    });

    this.sendCustomEvent(this.EventDict.CONNECTION_INFO, {
      detail: {
        log: [
          'SDP (Session Description Protocol) Answer For %s Created By %s:%o',
          remoteConnectionID,
          connectionID,
          sessionDescriptionAnswerWithOffererAndAnswererIncluded || sessionDescriptionAnswer
        ]
      }
    });

    return sessionDescriptionAnswerWithOffererAndAnswererIncluded || sessionDescriptionAnswer;
  }

  /**
   * @method
   * @returns {void}
   */
  closeAllConnections() {
    this.getConnections().forEach(({ connection }, remoteConnectionID) => {
      connection.close();
      this.sendCustomEvent(this.EventDict.CONNECTION_CLOSE, {
        detail: {
          remoteConnectionID: remoteConnectionID
        }
      });
    });
  }

  /**
   * @method
   * @param {string} remoteConnectionID
   * @returns {void}
   */
  closeConnection(remoteConnectionID) {
    this.getConnection(remoteConnectionID).connection.close();
    this.sendCustomEvent(this.EventDict.CONNECTION_CLOSE, {
      detail: {
        remoteConnectionID: remoteConnectionID
      }
    });
  }

  /**
   * @method
   * @param {string} connectionID
   * @returns {void}
   */
  deleteConnection(connectionID) {
    this.#connections.delete(connectionID);
  }

  /**
   * @method
   * @returns {ConnectionData[]}
   */
  getActiveConnections() {
    return this.getConnections().filter(({ channel }) => {
      return channel?.readyState === 'open';
    });
  }

  /**
   * @method
   * @param {string} connectionID
   * @returns {ConnectionData}
   */
  getConnection(connectionID) {
    const { incomingMediaStreams } = this.#connections.get(connectionID);
    return {
      ...this.#connections.get(connectionID),
      incomingMediaStreams: new Map(incomingMediaStreams.entries())
    };
  }

  /**
   * @method
   * @returns {ConnectionData[]}
   */
  getConnections() {
    return Array.from(this.#connections.keys()).map((connectionID) => {
      return this.getConnection(connectionID);
    });
  }

  /**
   * @method
   * @param {RTCSessionDescription} sessionDescription
   * @returns {string} answererID
   */
  getAnswererFromSessionDescription(sessionDescription) {
    return sessionDescription.sdp.match(/a=answerer:(\S+)/)[1];
  }

  /**
   * @method
   * @param {RTCSessionDescription} sessionDescription
   * @returns {string} offererID
   */
  getOffererFromSessionDescription(sessionDescription) {
    return sessionDescription.sdp.match(/a=offerer:(\S+)/)[1];
  }

  /**
   * @method
   * @param {string} connectionID
   * @returns {boolean}
   */
  hasActiveConnection(connectionID) {
    return this.hasConnection(connectionID)
      && this.getConnection(connectionID).channel?.readyState === 'open';
  }

  /**
   * @method
   * @param {string} connectionID
   * @returns {boolean}
   */
  hasConnection(connectionID) {
    return this.#connections.has(connectionID);
  }

  /**
   * @private
   * @method
   * @param {string} connectionID
   * @param {MediaStream} mediaStream
   * @returns {void}
   */
  #addIncomingMediaStreamToConnection(connectionID, mediaStream) {
    const connectionData = this.#getConnection(connectionID);

    if (connectionData.incomingMediaStreams.has(mediaStream.id)) {
      return;
    }

    connectionData.incomingMediaStreams.set(mediaStream.id, {
      stream: mediaStream,
      hasEnabledTracks: true
    });
  }

  /**
   * @private
   * @method
   * @param {RTCSessionDescription} sessionDescription
   * @param {string} offererID
   * @param {string} answererID
   * @returns {RTCSessionDescription}
   */
  #addOffererAndAnswererToSessionDescription(sessionDescription, offererID, answererID) {
    const { type, sdp } = sessionDescription;

    return {
      type: type,
      sdp: sdp + `a=offerer:${offererID}\r\na=answerer:${answererID}\r\n`
    };
  }

  /**
   * @private
   * @method
   * @param {RTCPeerConnection} connection
   * @param {RTCSessionDescription} offer
   * @returns {Promise<RTCSessionDescription>} sessionDescriptionAnswer
   */
  #createAnswer(connection, offer) {
    return new Promise((resolve) => {
      connection.setRemoteDescription(offer).then(() => {
        connection.createAnswer().then((answer) => {
          connection.setLocalDescription(answer).then(() => {
            this.#iceCandidateGatheringPromises.get(connection).then(() => {
              resolve(connection.localDescription);
            });
          });
        });
      }).catch((error) => {
        console.error(error);
      });
    });
  }

  /**
   * @private
   * @method
   * @param {RTCPeerConnection} connection
   * @returns {Promise<RTCSessionDescription>} sessionDescriptionOffer
   */
  #createOffer(connection) {
    return new Promise((resolve) => {
      connection.createOffer().then((offer) => {
        connection.setLocalDescription(offer).then(() => {
          this.#iceCandidateGatheringPromises.get(connection).then(() => {
            resolve(connection.localDescription);
          });
        });
      }).catch((error) => {
        console.error(error);
      });
    });
  }

  /**
   * @private
   * @method
   * @param {string} connectionID
   * @returns {ConnectionData}
   */
  #getConnection(connectionID) {
    return this.#connections.get(connectionID);
  }

  /**
   * @private
   * @method
   * @param {ArrayBuffer} messageData
   * @param {ArrayBufferMessageFileData} fileData
   * @param {ArrayBuffer[]} fileChunksReceived
   * @returns {void}
   */
  #handleArrayBufferMessage(messageData, fileData) {
    if (messageData.byteLength === 0) { // EOF
      this.sendCustomEvent(this.EventDict.REMOTE_FILE_RECEIVED, {
        detail: {
          ...fileData,
          dataURL: URL.createObjectURL(new Blob(fileData.fileChunks, { type: fileData.file.type }))
        }
      });

      return;
    }

    fileData.fileChunks.push(messageData);

    const bytesReceived = fileData.fileChunks.reduce((previousValue, currentValue) => {
      return previousValue + currentValue.byteLength;
    }, 0);

    this.sendCustomEvent(this.EventDict.REMOTE_FILE_CHUNK_RECEIVED, {
      detail: {
        ...fileData,
        fileChunks: {
          ...fileData.fileChunks
        },
        bytesLoaded: bytesReceived
      }
    });

    return;
  }

  /**
   * @private
   * @method
   * @param {MessageEvent} event
   * @param {string} connectionID
   * @param {string} remoteConnectionID
   */
  #onDataChannelMessage(event, connection, connectionID, remoteConnectionID) {
    const { target: dataChannel } = event;
    // ====================
    // ArrayBuffer (File)
    // ====================
    if (event.data instanceof ArrayBuffer) {
      return this.#handleArrayBufferMessage(event.data, this.#incomingFiles.get(remoteConnectionID));
    }
    // ====================
    // Message
    // ====================
    const data = JSON.parse(event.data);
    switch (data.type) {
      case DataChannelMessageType.MESSAGE:
        this.sendCustomEvent(this.EventDict.DATA_CHANNEL_MESSAGE, {
          detail: {
            fromID: data.fromID,
            message: data.message,
            messageType: 'message',
            toID: data.toID,
            unix: data.unix
          }
        });
        break;
      case DataChannelMessageType.FILE_INFO:
        this.#incomingFiles.set(remoteConnectionID, {
          file: data.file,
          fromID: data.fromID,
          toID: data.toID,
          unix: data.unix,
          fileChunks: []
        });
        this.sendCustomEvent(this.EventDict.REMOTE_FILE_TRANSFER_START, {
          detail: {
            file: data.file,
            fromID: data.fromID
          }
        });
        break;
      case DataChannelMessageType.FILE_TRANSFER_FAIL:
        this.sendCustomEvent(this.EventDict.REMOTE_FILE_TRANSFER_FAIL, {
          detail: {
            error: data.error,
            file: data.file,
            fromID: data.fromID
          }
        });
        break;
      case DataChannelMessageType.CAMERA_TRACK_DISABLE:
        this.sendCustomEvent(this.EventDict.REMOTE_CAMERA_TRACK_DISABLE, {
          detail: {
            author: data.author,
            mediaStreamID: data.mediaStreamID
          }
        });
        break;
      case DataChannelMessageType.CAMERA_TRACK_ENABLE:
        this.#getConnection(data.author).incomingMediaStreams.get(data.mediaStreamID).hasEnabledTracks = true;
        this.sendCustomEvent(this.EventDict.REMOTE_CAMERA_TRACK_ENABLE, {
          detail: {
            author: data.author,
            mediaStreamID: data.mediaStreamID
          }
        });
        break;
      case DataChannelMessageType.MICROPHONE_TRACK_ENABLE:
        this.#getConnection(data.author).incomingMediaStreams.get(data.mediaStreamID).hasEnabledTracks = true;
        this.sendCustomEvent(this.EventDict.REMOTE_MICROPHONE_TRACK_ENABLE, {
          detail: {
            author: data.author,
            mediaStreamID: data.mediaStreamID
          }
        });
        break;
      case DataChannelMessageType.USER_MEDIA_TRACKS_DISABLE:
        const { incomingMediaStreams } = this.#getConnection(data.author);
        const mediaStreamIDs = JSON.parse(data.mediaStreamIDs);
        mediaStreamIDs.forEach((mediaStreamID) => {
          incomingMediaStreams.get(mediaStreamID).hasEnabledTracks = false;
        });
        this.sendCustomEvent(this.EventDict.REMOTE_USER_MEDIA_TRACKS_DISABLE, {
          detail: {
            author: data.author,
            mediaStreamIDs: mediaStreamIDs
          }
        });
        break;
      case DataChannelMessageType.SCREEN_SHARE:
        this.sendCustomEvent(this.EventDict.REMOTE_SCREEN_SHARE, {
          detail: {
            author: data.author,
            mediaStreamID: data.mediaStreamID
          }
        });
        break;
      case DataChannelMessageType.SCREEN_SHARE_END:
        this.#getConnection(data.author).incomingMediaStreams.delete(data.mediaStreamID);
        this.sendCustomEvent(this.EventDict.REMOTE_SCREEN_SHARE_END, {
          detail: {
            author: data.author,
            mediaStreamID: data.mediaStreamID
          }
        });
        break;
      case DataChannelMessageType.SDP_ANSWER:
        this.setAnswer({
          connection: connection,
          connectionID: connectionID,
          remoteConnectionID: remoteConnectionID,
          sessionDesciptionAnswer: data.sdpAnswer
        });
        break;
      case DataChannelMessageType.SDP_OFFER:
        this.setOffer({
          connection: connection,
          connectionID: connectionID,
          remoteConnectionID: remoteConnectionID,
          sessionDescriptionOffer: data.sdpOffer
        }).then((sdpAnswer) => {
          sendDataChannelMessage({
            type: DataChannelMessageType.SDP_ANSWER,
            sdpAnswer: sdpAnswer
          }, dataChannel);
        });
        break;
      default:
        break;
    }
  }

  /**
   * @private
   * @method
   * @param {RTCPeerConnection} connection
   * @param {RTCSessionDescription} answer
   * @returns {Promise<void>}
   */
  async #setAnswer(connection, answer) {
    try {
      await connection.setRemoteDescription(answer);
    } catch (error) {
      console.error(error);
    }
  }
}

export { ConnectionsService };
